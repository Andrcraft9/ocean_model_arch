!------------------------------------------------------------------------------
! Generic for 2D sync routine:
! subroutine syncborder_data2D_TYPE(domain, data2d)
!        type(data2D_real8_type), intent(inout) :: data2d
!        type(domain_type), intent(in) :: domain
!        ...
! end subroutine
!
! Must be specified: 
!   _MPI_TYPE_
!
!------------------------------------------------------------------------------

integer :: dir, k, kk
integer :: sync_dir(8)
integer :: k_dir(8)
integer :: rank_dir(8)
integer :: nxs, nxe, nys, nye     ! Boundary points
integer :: hnxs, hnxe, hnys, hnye ! Halo points
integer :: buf_size
integer :: rk

! Update halo for inner blocks (only copy, without MPI send/recv)
!

do k = domain%start_inner, domain%start_inner + domain%bcount_inner - 1
    
    sync_dir(1) = _NXP_; k_dir(1) = domain%blocks_info(k)%k_nxp
    sync_dir(2) = _NXM_; k_dir(2) = domain%blocks_info(k)%k_nxm
    sync_dir(3) = _NYP_; k_dir(3) = domain%blocks_info(k)%k_nyp
    sync_dir(4) = _NYM_; k_dir(4) = domain%blocks_info(k)%k_nym

    sync_dir(5) = _NXP_NYP_; k_dir(5) = domain%blocks_info(k)%k_nxp_nyp
    sync_dir(6) = _NXP_NYM_; k_dir(6) = domain%blocks_info(k)%k_nxp_nym
    sync_dir(7) = _NXM_NYP_; k_dir(7) = domain%blocks_info(k)%k_nxm_nyp
    sync_dir(8) = _NXM_NYM_; k_dir(8) = domain%blocks_info(k)%k_nxm_nym
    
    do kk = 1, 8
        call get_boundary_points_of_block(domain, k_dir(kk), get_inverse_dir(sync_dir(kk)), nxs, nxe, nys, nye)
        call get_halo_points_of_block(domain, k, sync_dir(kk), hnxs, hnxe, hnys, hnye)
        data2d%block(k)%field(hnxs : hnxe, hnys : hnye) = data2d%block(k_dir(kk))%field(nxs : nxe, nys : nye)
    enddo
enddo

! Prepare MPI buffers for each near rank
!

sync_buf_pos = 1
do k = domain%start_boundary, domain%start_boundary + domain%bcount_boundary - 1

    sync_dir(1) = _NXP_; k_dir(1) = domain%blocks_info(k)%k_nxp; rank_dir(1) = domain%blocks_info(k)%rank_nxp
    sync_dir(2) = _NXM_; k_dir(2) = domain%blocks_info(k)%k_nxm; rank_dir(2) = domain%blocks_info(k)%rank_nxm
    sync_dir(3) = _NYP_; k_dir(3) = domain%blocks_info(k)%k_nyp; rank_dir(3) = domain%blocks_info(k)%rank_nyp
    sync_dir(4) = _NYM_; k_dir(4) = domain%blocks_info(k)%k_nym; rank_dir(4) = domain%blocks_info(k)%rank_nym

    sync_dir(5) = _NXP_NYP_; k_dir(5) = domain%blocks_info(k)%k_nxp_nyp; rank_dir(5) = domain%blocks_info(k)%rank_nxp_nyp
    sync_dir(6) = _NXP_NYM_; k_dir(6) = domain%blocks_info(k)%k_nxp_nym; rank_dir(6) = domain%blocks_info(k)%rank_nxp_nym
    sync_dir(7) = _NXM_NYP_; k_dir(7) = domain%blocks_info(k)%k_nxm_nyp; rank_dir(7) = domain%blocks_info(k)%rank_nxm_nyp
    sync_dir(8) = _NXM_NYM_; k_dir(8) = domain%blocks_info(k)%k_nxm_nym; rank_dir(8) = domain%blocks_info(k)%rank_nxm_nym

    do kk = 1, 8
        ! Get rank of proc (rk) for transfer in current direction. It is near rank.
        rk = rank_dir(kk)
        if (rk >= 0) then
            if (rk /= mpp_rank) then
                ! Set local block number (local number is relative to rk) and direction of transfer (direction is relative to rk)
                _SYNC_SEND_BUF_(sync_buf_pos(rk), rk) = get_inverse_dir(sync_dir(kk))
                sync_buf_pos(rk) = sync_buf_pos(rk) + 1
                _SYNC_SEND_BUF_(sync_buf_pos(rk), rk) = k_dir(kk)
                sync_buf_pos(rk) = sync_buf_pos(rk) + 1

                ! Set boundary points
                call get_boundary_points_of_block(domain, k, sync_dir(kk), nxs, nxe, nys, nye)

                ! Pack buffer
                buf_size = (nxe - nxs + 1) + (nye - nys + 1)
                _SYNC_SEND_BUF_(sync_buf_pos(rk) : sync_buf_pos(rk) + buf_size - 1, rk) = reshape(data2d%block(k)%field(nxs : nxe, nys : nye), (/buf_size/))
                sync_buf_pos(rk) = sync_buf_pos(rk) + buf_size
            endif
        endif
    enddo
enddo

! Send/Recv MPI buffers for each near rank
!

! Unpack MPI buffers
!

sync_buf_pos = 1
do kk = 1, domain%amount_of_ranks_near
    rk = domain%ranks_near(kk)

    dir = _SYNC_RECV_BUF_(sync_buf_pos(rk), rk)
    sync_buf_pos(rk) = sync_buf_pos(rk) + 1
    k = _SYNC_RECV_BUF_(sync_buf_pos(rk), rk)
    sync_buf_pos(rk) = sync_buf_pos(rk) + 1

    call get_halo_points_of_block(domain, k, dir, hnxs, hnxe, hnys, hnye)

    buf_size = (hnxe - hnxs + 1) + (hnye - hnys + 1)
    data2d%block(k)%field(hnxs : hnxe, hnys : hnye) = reshape(_SYNC_RECV_BUF_(sync_buf_pos(rk) : sync_buf_pos(rk) + buf_size - 1, rk), (/hnxe - hnxs + 1, hnye - hnys + 1/))
    sync_buf_pos(rk) = sync_buf_pos(rk) + buf_size

    ! TODO: When end?
enddo


! Update halo for boundray blocks
!

do k = domain%start_boundary, domain%start_boundary + domain%bcount_boundary - 1

    sync_dir(1) = _NXP_; k_dir(1) = domain%blocks_info(k)%k_nxp; rank_dir(1) = domain%blocks_info(k)%rank_nxp
    sync_dir(2) = _NXM_; k_dir(2) = domain%blocks_info(k)%k_nxm; rank_dir(2) = domain%blocks_info(k)%rank_nxm
    sync_dir(3) = _NYP_; k_dir(3) = domain%blocks_info(k)%k_nyp; rank_dir(3) = domain%blocks_info(k)%rank_nyp
    sync_dir(4) = _NYM_; k_dir(4) = domain%blocks_info(k)%k_nym; rank_dir(4) = domain%blocks_info(k)%rank_nym

    sync_dir(5) = _NXP_NYP_; k_dir(5) = domain%blocks_info(k)%k_nxp_nyp; rank_dir(5) = domain%blocks_info(k)%rank_nxp_nyp
    sync_dir(6) = _NXP_NYM_; k_dir(6) = domain%blocks_info(k)%k_nxp_nym; rank_dir(6) = domain%blocks_info(k)%rank_nxp_nym
    sync_dir(7) = _NXM_NYP_; k_dir(7) = domain%blocks_info(k)%k_nxm_nyp; rank_dir(7) = domain%blocks_info(k)%rank_nxm_nyp
    sync_dir(8) = _NXM_NYM_; k_dir(8) = domain%blocks_info(k)%k_nxm_nym; rank_dir(8) = domain%blocks_info(k)%rank_nxm_nym

    do kk = 1, 8
        if (rank_dir(kk) >= 0) then
            if (rank_dir(kk) == mpp_rank) then
                ! Copy data
                !

                call get_boundary_points_of_block(domain, k_dir(kk), get_inverse_dir(sync_dir(kk)), nxs, nxe, nys, nye)
                call get_halo_points_of_block(domain, k, sync_dir(kk), hnxs, hnxe, hnys, hnye)
                data2d%block(k)%field(hnxs : hnxe, hnys : hnye) = data2d%block(k_dir(kk))%field(nxs : nxe, nys : nye)
            endif
        endif
    enddo
enddo